#version 440

// Sources
// https://github.com/bcrusco/Forward-Plus-Renderer
// https://github.com/WindyDarian/Vulkan-Forward-Plus-Renderer

#define DESCRIPTOR_SET_LIGHTS 0
#define DESCRIPTOR_SET_SCENE (DESCRIPTOR_SET_LIGHTS +1)

#define DESCRIPTOR_SET_LIGHTS_BINDING_LIGHT_BUFFERS 0
#define DESCRIPTOR_SET_LIGHTS_BINDING_TILE_VIS_LIGHT_INDEX_BUFFER (DESCRIPTOR_SET_LIGHTS_BINDING_LIGHT_BUFFERS +1)
#define DESCRIPTOR_SET_LIGHTS_BINDING_SHADOW_DATA (DESCRIPTOR_SET_LIGHTS_BINDING_TILE_VIS_LIGHT_INDEX_BUFFER +1)
#define DESCRIPTOR_SET_LIGHTS_BINDING_VIS_LIGHT_INDEX_BUFFER (DESCRIPTOR_SET_LIGHTS_BINDING_SHADOW_DATA +1)
#define DESCRIPTOR_SET_LIGHTS_BINDING_DEPTH_MAP (DESCRIPTOR_SET_LIGHTS_BINDING_VIS_LIGHT_INDEX_BUFFER +1)

#include "../modules/conditionals.gls"
#include "../modules/sh_light_source.gls"
#include "../modules/sh_camera_info.gls"
#include "../modules/sh_rendersettings.gls"
#include "../lighting/sh_light_sources.gls"
#include "../functions/fs_linearize_depth.gls"
#include "../math/intersection.gls"
#include "cs_forwardp_settings.gls"

layout(std430,LAYOUT_ID(DESCRIPTOR_SET_LIGHTS,DESCRIPTOR_SET_LIGHTS_BINDING_VIS_LIGHT_INDEX_BUFFER)) buffer VisibleLightIndicesBuffer {
	uint visibleBits[];
} visibleLightIndicesBuffer;

layout(LAYOUT_PUSH_CONSTANTS()) uniform LightInfo
{
	uint lightCount;
	uint sceneFlag;
	uint viewportResolution;
} u_lightInfo;

layout(LAYOUT_ID(DESCRIPTOR_SET_LIGHTS,DESCRIPTOR_SET_LIGHTS_BINDING_DEPTH_MAP)) uniform sampler2D u_sceneDepth;

// Specialization constants not supported on some GPUs?
// layout(constant_id = 1) const uint FORWARDP_TILE_SIZE = 16;
#define FORWARDP_TILE_SIZE 16

#define DEBUG_FORWARDP_OUTPUT_MODE_DEPTH_NONE 0
#define DEBUG_FORWARDP_OUTPUT_MODE_DEPTH_BUFFER 1
#define DEBUG_FORWARDP_OUTPUT_MODE_UV_X 2
#define DEBUG_FORWARDP_OUTPUT_MODE_UV_Y 3
#define DEBUG_FORWARDP_OUTPUT_MODE_LOCATION_X 4
#define DEBUG_FORWARDP_OUTPUT_MODE_LOCATION_Y 5

#define DEBUG_FORWARDP_OUTPUT_MODE DEBUG_FORWARDP_OUTPUT_MODE_DEPTH_NONE

// Shared values between all the threads in the group
shared uint minDepthInt;
shared uint maxDepthInt;
shared uint visibleLightCount;
// Shared local storage for visible indices, will be written out to the global buffer at the end
shared int visibleLightIndices[MAX_SCENE_LIGHTS];

// vulkan ndc, minDepth = 0.0, maxDepth = 1.0
const vec2 ndc_upper_left = vec2(-1.0,-1.0);
const float ndc_near_plane = 0.0;
const float ndc_far_plane = 1.0;

struct ViewFrustum
{
	vec4 planes[6];
	vec3 points[8]; // 0-3 near 4-7 far

	float minDepth;
	float maxDepth;

	// AABB
	vec3 min;
	vec3 max;
};
shared ViewFrustum frustum;

// Construct view frustum
ViewFrustum create_frustum(ivec2 tile_id,float min_depth,float max_depth,uint viewportW,uint viewportH)
{
	//min_depth = (min_depth +1) /2.0;
	//max_depth = (max_depth +1) /2.0;
	mat4 inv_projview = inverse(u_camera.VP);

	vec2 ndc_size_per_tile = 2.0 *vec2(FORWARDP_TILE_SIZE,FORWARDP_TILE_SIZE) /vec2(viewportW,viewportH);

	vec2 ndc_pts[4];  // corners of tile in ndc
	ndc_pts[0] = ndc_upper_left +tile_id *ndc_size_per_tile;  // upper left
	ndc_pts[1] = vec2(ndc_pts[0].x +ndc_size_per_tile.x,ndc_pts[0].y); // upper right
	ndc_pts[2] = ndc_pts[0] +ndc_size_per_tile;
	ndc_pts[3] = vec2(ndc_pts[0].x,ndc_pts[0].y + ndc_size_per_tile.y); // lower left

	ViewFrustum frustum;

	frustum.min = vec3(FLT_MAX,FLT_MAX,FLT_MAX);
	frustum.max = -frustum.min;

	vec4 temp;
	for(int i=0; i<4;i++)
	{
		temp = inv_projview *vec4(ndc_pts[i],min_depth,1.0);
		frustum.points[i] = temp.xyz /temp.w;
		temp = inv_projview *vec4(ndc_pts[i],max_depth,1.0);
		frustum.points[i +4] = temp.xyz /temp.w;

		vec3 p0 = frustum.points[i];
		vec3 p1 = frustum.points[i +4];
		for(int j=0;j<3;++j)
		{
			frustum.min[j] = min(frustum.min[j],p0[j]);
			frustum.min[j] = min(frustum.min[j],p1[j]);

			frustum.max[j] = max(frustum.max[j],p0[j]);
			frustum.max[j] = max(frustum.max[j],p1[j]);
		}
	}

	vec3 temp_normal;
	for(int i=0;i<4;i++)
	{
		//Cax+Cby+Ccz+Cd = 0, planes[i] = (Ca, Cb, Cc, Cd)
		// temp_normal: normal without normalization
		temp_normal = cross(frustum.points[i] -u_renderSettings.posCam.xyz,frustum.points[i +1] -u_renderSettings.posCam.xyz);
		temp_normal = normalize(temp_normal);
		frustum.planes[i] = vec4(temp_normal,-dot(temp_normal,frustum.points[i]));
	}
	// near plane
	{
		temp_normal = cross(frustum.points[1] -frustum.points[0],frustum.points[3] -frustum.points[0]);
		temp_normal = normalize(temp_normal);
		frustum.planes[4] = vec4(temp_normal, -dot(temp_normal,frustum.points[0]));
	}


	// far plane
	{
		temp_normal = cross(frustum.points[7] -frustum.points[4],frustum.points[5] -frustum.points[4]);
		temp_normal = normalize(temp_normal);
		frustum.planes[5] = vec4(temp_normal,-dot(temp_normal,frustum.points[4]));
	}

	frustum.minDepth = min_depth;
	frustum.maxDepth = max_depth;
	return frustum;
}

bool is_light_in_frustum(LightSourceData light,ViewFrustum frustum)
{
	vec3 lightPos = light.position.xyz;
	float lightDist = light.position.w;
	bool result = true;

    // Step1: sphere-plane test
	for(int i=0;i<6;i++)
	{
		if(dot(lightPos,frustum.planes[i].xyz) +frustum.planes[i].w  < -lightDist)
		{
			result = false;	
			break;
		}
	}

    if(!result)
		return false;

    // Step2: bbox corner test (to reduce false positive)
    vec3 light_bbox_max = lightPos +vec3(lightDist);
    vec3 light_bbox_min = lightPos -vec3(lightDist);
    int probe;
    probe=0; for(int i=0; i<8; i++) probe += ((frustum.points[i].x > light_bbox_max.x)?1:0); if(probe==8) return false;
    probe=0; for(int i=0; i<8; i++) probe += ((frustum.points[i].x < light_bbox_min.x)?1:0); if(probe==8) return false;
    probe=0; for(int i=0; i<8; i++) probe += ((frustum.points[i].y > light_bbox_max.y)?1:0); if(probe==8) return false;
    probe=0; for(int i=0; i<8; i++) probe += ((frustum.points[i].y < light_bbox_min.y)?1:0); if(probe==8) return false;
    probe=0; for(int i=0; i<8; i++) probe += ((frustum.points[i].z > light_bbox_max.z)?1:0); if(probe==8) return false;
    probe=0; for(int i=0; i<8; i++) probe += ((frustum.points[i].z < light_bbox_min.z)?1:0); if(probe==8) return false;

    if((light.flags &FLIGHT_TYPE_SPOT) != 0)
    {
    	// Cone culling
		// See https://simoncoenen.com/blog/programming/graphics/SpotlightCulling.html
		vec3 extents = (frustum.max -frustum.min) /2.0;
		vec3 center = (frustum.max +frustum.min) /2.0;
		float radius = length(extents);
		if(!intersect_cone_sphere(light.position.xyz,light.direction.xyz,light.position.w,light.cutoffOuter,vec4(center,radius)))
			return false;
	}

	return true;
}

#define SHADOW_INDEX_INTEGER_COUNT ((MAX_ACTIVE_SHADOW_SOURCES /32) +1)

layout(local_size_x = FORWARDP_TILE_SIZE,local_size_y = FORWARDP_TILE_SIZE,local_size_z = 1) in;
void main()
{
	ivec2 location = ivec2(gl_GlobalInvocationID.xy);
	ivec2 tileID = ivec2(gl_WorkGroupID.xy);
	ivec2 tileNumber = ivec2(gl_NumWorkGroups.xy);
	uint index = tileID.y *tileNumber.x +tileID.x;

	// Initialize shared global values for depth and light count
	if(gl_LocalInvocationIndex == 0)
	{
		minDepthInt = 0xFFFFFFFF;
		maxDepthInt = 0;
		visibleLightCount = 0;
	}

	if(gl_WorkGroupID.x == 0 && gl_WorkGroupID.y == 0)
	{
		for(uint i=0;i<SHADOW_INDEX_INTEGER_COUNT;++i)
			visibleLightIndicesBuffer.visibleBits[i] = 0;
	}

	memoryBarrierShared();
	barrier();

	uint viewportW = u_lightInfo.viewportResolution>>16;
	uint viewportH = (u_lightInfo.viewportResolution<<16)>>16;

	// Step 1: Calculate the minimum and maximum depth values (from the depth buffer) for this group's tile
	float maxDepth, minDepth;
	vec2 uv = vec2(location) /vec2(float(viewportW),float(viewportH));
	float depth = texture(u_sceneDepth,uv).r;

	// Convert depth to uint so we can do atomic min and max comparisons between the threads
	uint depthInt = floatBitsToUint(depth);
	atomicMin(minDepthInt,depthInt);
	atomicMax(maxDepthInt,depthInt);

	memoryBarrierShared();
	barrier();

	// Step 2: One thread should calculate the frustum planes to be used for this tile
	if(gl_LocalInvocationIndex == 0)
	{
		// Convert the min and max across the entire tile back to float
		minDepth = uintBitsToFloat(minDepthInt);
		maxDepth = uintBitsToFloat(maxDepthInt);

		frustum = create_frustum(tileID,minDepth,maxDepth,viewportW,viewportH);
	}

	memoryBarrierShared();
	barrier();

	// Step 3: Cull lights.
	// Parallelize the threads against the lights now.
	// Can handle 256 simultaneously. Anymore lights than that and additional passes are performed
	uint threadCount = FORWARDP_TILE_SIZE *FORWARDP_TILE_SIZE;
	uint passCount = (u_lightInfo.lightCount +threadCount -1) /threadCount;
	for(uint i=0; i<passCount;i++)
	{
		// Get the lightIndex to test for this thread / pass. If the index is >= light count, then this thread can stop testing lights
		uint lightIndex = i *threadCount +gl_LocalInvocationIndex;
		if(lightIndex >= u_lightInfo.lightCount)
			break;
		if((lightBuffer.data[lightIndex].flags &FLIGHT_TURNED_ON) == 0)// || (lightBuffer.data[lightIndex].flags &FLIGHT_BAKED_LIGHT_SOURCE) != 0)
			continue;

		if((lightBuffer.data[lightIndex].sceneFlags &u_lightInfo.sceneFlag) == 0)
			continue; // Light is not in scene
			
		// We check if the light exists in our frustum
		if(((lightBuffer.data[lightIndex].flags &FLIGHT_TYPE_DIRECTIONAL) != 0 || is_light_in_frustum(lightBuffer.data[lightIndex],frustum)))
		{
			uint offset = atomicAdd(visibleLightCount, 1);
			visibleLightIndices[offset] = int(lightIndex);
		}
	}

	memoryBarrierShared();
	barrier();
#if DEBUG_FORWARDP_OUTPUT_MODE == DEBUG_FORWARDP_OUTPUT_MODE_DEPTH_BUFFER
	if(gl_LocalInvocationIndex == 0)
	{
		uint startOffset = index *MAX_SCENE_LIGHTS;
		visibleLightTileIndicesBuffer.data[startOffset].index = floatBitsToInt(minDepth);
	}
#elif DEBUG_FORWARDP_OUTPUT_MODE == DEBUG_FORWARDP_OUTPUT_MODE_UV_X
	if(gl_LocalInvocationIndex == 0)
	{
		uint startOffset = index *MAX_SCENE_LIGHTS;
		visibleLightTileIndicesBuffer.data[startOffset].index = floatBitsToInt(uv.x);
	}
#elif DEBUG_FORWARDP_OUTPUT_MODE == DEBUG_FORWARDP_OUTPUT_MODE_UV_Y
	if(gl_LocalInvocationIndex == 0)
	{
		uint startOffset = index *MAX_SCENE_LIGHTS;
		visibleLightTileIndicesBuffer.data[startOffset].index = floatBitsToInt(uv.y);
	}
#elif DEBUG_FORWARDP_OUTPUT_MODE == DEBUG_FORWARDP_OUTPUT_MODE_LOCATION_X
	if(gl_LocalInvocationIndex == 0)
	{
		uint startOffset = index *MAX_SCENE_LIGHTS;
		visibleLightTileIndicesBuffer.data[startOffset].index = location.x;
	}
#elif DEBUG_FORWARDP_OUTPUT_MODE == DEBUG_FORWARDP_OUTPUT_MODE_LOCATION_Y
	if(gl_LocalInvocationIndex == 0)
	{
		uint startOffset = index *MAX_SCENE_LIGHTS;
		visibleLightTileIndicesBuffer.data[startOffset].index = location.y;
	}
#else
	// One thread should fill the global light buffer
	if(gl_LocalInvocationIndex == 0)
	{
		// Note: Spot-, point- and directional lights have separate ranges in visibleLightTileIndicesBuffer (for each tile),
		// which avoids having to do expensive if-conditionals in the fragment shader later.
		// Spot light range: [SCENE_SPOT_LIGHT_BUFFER_START,SCENE_SPOT_LIGHT_BUFFER_END)
		// Point light range: [SCENE_POINT_LIGHT_BUFFER_START,SCENE_POINT_LIGHT_BUFFER_END)
		// Directional light range: [SCENE_DIRECTIONAL_LIGHT_BUFFER_START,SCENE_DIRECTIONAL_LIGHT_BUFFER_END)
		// (Each is relative to (index *MAX_SCENE_LIGHTS), i.e. the tile start offset)

		// Determine position in global buffer
		uint startOffset = index *MAX_SCENE_LIGHTS;
		uint ispot = 0;
		uint ipoint = 0;
		uint idirectional = 0;
		for(uint i=0;i<visibleLightCount;i++)
		{
			uint lightIndex = visibleLightIndices[i];
			LightSourceData lightData = lightBuffer.data[lightIndex];

			uint spotLight = lightData.flags &FLIGHT_TYPE_SPOT;
			uint pointLight = lightData.flags &FLIGHT_TYPE_POINT;
			uint dirLight = lightData.flags &FLIGHT_TYPE_DIRECTIONAL;

			uint offset = 
				(SCENE_SPOT_LIGHT_BUFFER_START +ispot) *when_neq(spotLight,0) +
				(SCENE_POINT_LIGHT_BUFFER_START +ipoint) *when_neq(pointLight,0) +
				(SCENE_DIRECTIONAL_LIGHT_BUFFER_START +idirectional) *when_neq(dirLight,0);
			uint endOffset = 
				SCENE_SPOT_LIGHT_BUFFER_END *when_neq(spotLight,0) +
				SCENE_POINT_LIGHT_BUFFER_END *when_neq(pointLight,0) +
				SCENE_DIRECTIONAL_LIGHT_BUFFER_END *when_neq(dirLight,0);
			if(offset >= endOffset)
				continue;
			ispot += when_neq(spotLight,0);
			ipoint += when_neq(pointLight,0);
			idirectional += when_neq(dirLight,0);

			visibleLightTileIndicesBuffer.data[startOffset +offset].index = int(lightIndex);
			if(lightData.shadowIndex == 0) // Light source with shadow?
				continue;
			uint shadowIdx = lightData.shadowIndex -1; // Shadow index is offset by 1, index of 0 means no shadow
			uint integerIdx = shadowIdx /32;
			visibleLightIndicesBuffer.visibleBits[integerIdx] |= 1<<shadowIdx; // Set bit according to shadow buffer index
		}

		//visibleLightTileIndicesBuffer.data[startOffset +SCENE_SPOT_LIGHT_BUFFER_START].index = int(ispot) -1;
		//visibleLightTileIndicesBuffer.data[startOffset +SCENE_POINT_LIGHT_BUFFER_START].index = int(ipoint) -1;
		//visibleLightTileIndicesBuffer.data[startOffset +SCENE_DIRECTIONAL_LIGHT_BUFFER_START].index = int(idirectional) -1;

		// Unless we have totally filled the entire array, mark its end with -1
		// Final shader step will use this to determine where to stop (without having to pass the light count)
		if(startOffset +ispot != SCENE_SPOT_LIGHT_BUFFER_END)
			visibleLightTileIndicesBuffer.data[startOffset +SCENE_SPOT_LIGHT_BUFFER_START +ispot].index = -1;
		if(startOffset +ipoint != SCENE_POINT_LIGHT_BUFFER_END)
			visibleLightTileIndicesBuffer.data[startOffset +SCENE_POINT_LIGHT_BUFFER_START +ipoint].index = -1;
		if(startOffset +idirectional != SCENE_DIRECTIONAL_LIGHT_BUFFER_END)
			visibleLightTileIndicesBuffer.data[startOffset +SCENE_DIRECTIONAL_LIGHT_BUFFER_START +idirectional].index = -1;
	}
#endif
}
