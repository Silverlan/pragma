/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * Copyright (c) 2021 Silverlan
 */
#ifdef _MSC_VER
#include "stdafx_shared.h"
#include "pragma/lua/lad/doc_validator.hpp"

using namespace pragma::lua;

void DocValidator::ValidateCollection(const pragma::doc::Collection &collection)
{
	auto name = collection.GetName();
	auto it = std::find_if(m_classes.begin(), m_classes.end(), [&name](const LuaClassInfo &luaClass) { return luaClass.name == name; });
	if(it == m_classes.end())
		Con::cout << "CLASS NOT FOUND!" << Con::endl;
	//find_item<pragma::doc::Function>(collection,name,&pragma::doc::Collection::GetFunctions);
	for(auto &f : collection.GetFunctions()) {
	}
}

void DocValidator::GetClassInfo(lua_State *L, luabind::detail::class_rep *crep)
{
	crep->get_table(L);
	luabind::object table(luabind::from_stack(L, -1));
	lua_pop(L, 1);

	std::size_t index = 1;

	for(luabind::iterator i(table), e; i != e; ++i) {
		std::string key;
		auto lkey = i.key();
		lkey.push(L);
		if(Lua::IsString(L, -1))
			key = Lua::CheckString(L, -1);
		Lua::Pop(L, 1);

		auto type = luabind::type(*i);
		switch(type) {
		case LUA_TFUNCTION:
			{
				auto *f = FindItem<pragma::doc::Function>(key, &pragma::doc::Collection::GetFunctions);
				if(f == nullptr) {
					std::stringstream ss;
					ss << "Function '" << key << "' not found!";
					WriteToLog(ss);
				}
				break;
			}
		case LUA_TBOOLEAN:
			break;
		case LUA_TNUMBER:
			break;
		case LUA_TSTRING:
			break;
		case LUA_TTABLE:
			break;
		case LUA_TUSERDATA:
			break;
		case LUA_TLIGHTUSERDATA:
			break;
		}
		if(type != LUA_TFUNCTION)
			Con::cout << "Type: " << type << Con::endl;
		if(type == LUA_TNUMBER) {
		}
		if(type != LUA_TFUNCTION)
			continue;

		// We have to create a temporary `object` here, otherwise the proxy
		// returned by operator->() will mess up the stack. This is a known
		// problem that probably doesn't show up in real code very often.
		luabind::object member(*i);
		member.push(L);
		luabind::detail::stack_pop pop(L, 1);

		if(lua_tocfunction(L, -1) == &luabind::detail::property_tag) {
			//result.attributes[index++] = i.key();
		}
		else {
			//result.methods[i.key()] = *i;
		}
	}
}
#endif
